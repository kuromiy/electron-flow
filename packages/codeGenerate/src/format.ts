/**
 * Phase 3: Template Literalsベースのコード生成エンジン
 * 外部テンプレートライブラリに依存しない実装
 */

import type { PackageInfo, ZodObjectInfo, AutoCodeOption, FunctionInfo, ParameterInfo } from './index.js';
import { codeValidator, codeFormatter, type ValidationResult } from './validation.js';

/**
 * ファイルメタデータ
 */
export interface FileMetadata {
  timestamp: string;
  sourcePath?: string;
  target: 'preload' | 'handler' | 'types';
}

/**
 * ベースジェネレーター抽象クラス
 */
abstract class BaseGenerator {
  /**
   * ファイルヘッダーを生成
   */
  protected generateFileHeader(metadata: FileMetadata): string {
    return `/**
 * Auto-generated by electron-flow
 * Generated at: ${metadata.timestamp}
 * Target: ${metadata.target}
 * 
 * DO NOT MODIFY THIS FILE DIRECTLY
 * This file is automatically generated and will be overwritten
 */

`;
  }

  /**
   * インポート文を生成
   */
  protected generateImports(imports: string[]): string {
    if (imports.length === 0) return '';
    return imports.join('\n') + '\n\n';
  }

  /**
   * 関数のパラメータからctxを除外して取得
   */
  protected getParametersWithoutContext(fn: FunctionInfo): ParameterInfo[] {
    return fn.parameters.filter(p => p.name !== 'ctx');
  }

  /**
   * パラメータの型定義文字列を生成
   */
  protected formatParameterTypes(params: ParameterInfo[]): string {
    return params
      .map(p => `${p.name}${p.isOptional ? '?' : ''}: ${p.type.text}`)
      .join(', ');
  }

  /**
   * パラメータの引数リストを生成
   */
  protected formatParameterArgs(params: ParameterInfo[]): string {
    return params.map(p => p.name).join(', ');
  }

  /**
   * 戻り値の型からPromiseを除去
   */
  protected extractReturnType(returnType: string): string {
    const promiseMatch = returnType.match(/^Promise<(.+)>$/);
    return promiseMatch?.[1] ?? returnType;
  }
}

/**
 * プリロードスクリプト生成
 */
class PreloadGenerator extends BaseGenerator {
  generate(packages: PackageInfo[]): string {
    const functions = packages.flatMap(pkg => pkg.functions);
    const imports = this.generatePreloadImports();
    const methods = this.generateApiMethods(functions);
    const globalDeclaration = this.generateGlobalDeclaration();
    
    const metadata: FileMetadata = {
      timestamp: new Date().toISOString(),
      target: 'preload'
    };
    
    return (
      this.generateFileHeader(metadata) +
      imports +
      this.generateElectronAPI(methods) +
      '\n\n' +
      globalDeclaration
    );
  }

  private generatePreloadImports(): string {
    return this.generateImports([
      "import { ipcRenderer } from 'electron';"
    ]);
  }

  private generateApiMethods(functions: FunctionInfo[]): string {
    return functions
      .map(fn => this.generateApiMethod(fn))
      .join(',\n');
  }

  private generateApiMethod(fn: FunctionInfo): string {
    const params = this.getParametersWithoutContext(fn);
    const paramTypes = this.formatParameterTypes(params);
    const args = this.formatParameterArgs(params);
    const argsStr = args ? `, ${args}` : '';
    
    return `  ${fn.name}: (${paramTypes}) =>\n    ipcRenderer.invoke('${fn.name}'${argsStr})`;
  }

  private generateElectronAPI(methods: string): string {
    return `export const electronAPI = {\n${methods}\n};`;
  }

  private generateGlobalDeclaration(): string {
    return `declare global {\n  interface Window {\n    electronAPI: typeof electronAPI;\n  }\n}`;
  }
}

/**
 * IPCハンドラー生成
 */
class HandlerGenerator extends BaseGenerator {
  generate(
    packages: PackageInfo[], 
    errorHandler?: AutoCodeOption['errorHandler']
  ): string {
    const imports = this.generateHandlerImports(packages);
    const handlers = this.generateHandlers(packages);
    const errorHandlerCode = this.generateErrorHandler(errorHandler);
    
    const metadata: FileMetadata = {
      timestamp: new Date().toISOString(),
      target: 'handler'
    };
    
    return (
      this.generateFileHeader(metadata) +
      imports +
      errorHandlerCode +
      '\n' +
      this.generateAutoGenerateHandlers(handlers)
    );
  }

  private generateHandlerImports(packages: PackageInfo[]): string {
    const imports = [
      "import { IpcMainInvokeEvent } from 'electron';"
    ];
    
    // API関数のインポート
    packages.forEach(pkg => {
      if (pkg.functions.length > 0) {
        const functionNames = pkg.functions.map(fn => fn.name).join(', ');
        // PackageInfoには直接importPathがないので、関数からimportPathを取得
        const importPath = pkg.functions[0]?.importPath ?? pkg.filePath;
        imports.push(`import { ${functionNames} } from '${importPath}';`);
      }
    });
    
    // Context型のインポート（設定に応じて）
    imports.push("import { Context } from '../types/context';");
    
    return this.generateImports(imports);
  }

  private generateHandlers(packages: PackageInfo[]): string {
    const handlers = packages.flatMap(pkg => 
      pkg.functions.map(fn => this.generateHandler(fn))
    );
    
    return handlers.join(',\n\n');
  }

  private generateHandler(fn: FunctionInfo): string {
    const params = this.getParametersWithoutContext(fn);
    const hasParams = params.length > 0;
    const paramList = hasParams ? ', args: unknown' : '';
    const apiCallArgs = hasParams ? 'ctx, args' : 'ctx';
    const awaitKeyword = fn.isAsync ? 'await ' : '';
    
    return `  "${fn.name}": (baseCtx: Omit<Context, "event">) => {\n    return async (event: IpcMainInvokeEvent${paramList}) => {\n      const ctx: Context = { ...baseCtx, event };\n      \n      try {\n        const result = ${awaitKeyword}${fn.name}(${apiCallArgs});\n        return { success: true, data: result };\n      } catch (error) {\n        return handleError(error, ctx);\n      }\n    };\n  }`;
  }

  private generateErrorHandler(errorHandler?: AutoCodeOption['errorHandler']): string {
    if (errorHandler) {
      return this.generateCustomErrorHandler(errorHandler);
    } else {
      return this.generateDefaultErrorHandler();
    }
  }

  private generateCustomErrorHandler(config: AutoCodeOption['errorHandler']): string {
    if (!config) return this.generateDefaultErrorHandler();
    
    const imports = `import { ${config.handlerName} } from '${config.handlerPath}';\n\n`;
    const fallback = config.defaultHandler ? 
      '    return defaultErrorHandler(error, ctx);' : 
      '    throw handlerError;';
    
    return imports + `function handleError(error: Error, ctx: Context): Result<never> {\n  try {\n    return ${config.handlerName}(error, ctx);\n  } catch (handlerError) {\n${fallback}\n  }\n}\n`;
  }

  private generateDefaultErrorHandler(): string {
    return `function handleError(error: Error, ctx: Context): Result<never> {\n  return {\n    success: false,\n    error: {\n      message: error.message || 'Unknown error',\n      type: error.constructor.name,\n      timestamp: new Date().toISOString()\n    }\n  };\n}\n`;
  }

  private generateAutoGenerateHandlers(handlers: string): string {
    return `export const autoGenerateHandlers = {\n${handlers}\n};`;
  }
}

/**
 * TypeScript型定義生成
 */
class TypeDefinitionGenerator extends BaseGenerator {
  generate(packages: PackageInfo[], zodInfos: ZodObjectInfo[]): string {
    const imports = this.generateTypeImports(packages, zodInfos);
    const resultType = this.generateResultType();
    const electronAPI = this.generateElectronAPIInterface(packages);
    const globalDeclaration = this.generateGlobalDeclaration();
    
    const metadata: FileMetadata = {
      timestamp: new Date().toISOString(),
      target: 'types'
    };
    
    return (
      this.generateFileHeader(metadata) +
      imports +
      resultType +
      '\n\n' +
      electronAPI +
      '\n\n' +
      globalDeclaration
    );
  }

  private generateTypeImports(packages: PackageInfo[], zodInfos: ZodObjectInfo[]): string {
    const imports: string[] = [];
    
    // API関数の型をインポート
    packages.forEach(pkg => {
      if (pkg.functions.length > 0) {
        const types = new Set<string>();
        pkg.functions.forEach(fn => {
          fn.parameters.forEach(param => {
            if (param.name !== 'ctx' && this.isCustomType(param.type.text)) {
              types.add(param.type.text);
            }
          });
          const returnType = this.extractReturnType(fn.returnType.text);
          if (this.isCustomType(returnType)) {
            types.add(returnType);
          }
        });
        
        if (types.size > 0) {
          imports.push(`import type { ${Array.from(types).join(', ')} } from '${pkg.filePath}';`);
        }
      }
    });
    
    return this.generateImports(imports);
  }

  private generateResultType(): string {
    return `type Result<T> = \n  | { success: true; data: T }\n  | { success: false; error: ErrorDetails };\n\ninterface ErrorDetails {\n  message: string;\n  type: string;\n  details?: unknown;\n  timestamp: string;\n}`;
  }

  private generateElectronAPIInterface(packages: PackageInfo[]): string {
    const functions = packages.flatMap(pkg => pkg.functions);
    const methods = functions
      .map(fn => this.generateInterfaceMethod(fn))
      .join('\n');
    
    return `interface ElectronAPI {\n${methods}\n}`;
  }

  private generateInterfaceMethod(fn: FunctionInfo): string {
    const params = this.getParametersWithoutContext(fn);
    const paramTypes = this.formatParameterTypes(params);
    const returnType = this.extractReturnType(fn.returnType.text);
    
    return `  ${fn.name}: (${paramTypes}) => Promise<Result<${returnType}>>;`;
  }

  private generateGlobalDeclaration(): string {
    return `declare global {\n  interface Window {\n    electronAPI: ElectronAPI;\n  }\n}`;
  }

  private isCustomType(type: string): boolean {
    const primitiveTypes = ['string', 'number', 'boolean', 'void', 'any', 'unknown'];
    return !primitiveTypes.includes(type) && !type.includes('[]') && !type.startsWith('Promise<');
  }
}

// ジェネレーターのインスタンス
const preloadGenerator = new PreloadGenerator();
const handlerGenerator = new HandlerGenerator();
const typeGenerator = new TypeDefinitionGenerator();

/**
 * プリロードスクリプトを生成
 */
export function generatePreloadScript(packages: PackageInfo[]): string {
  const code = preloadGenerator.generate(packages);
  const formatted = codeFormatter.format(code);
  
  // デバッグ用バリデーション（開発時のみ）
  if (process.env['NODE_ENV'] === 'development') {
    const validation = codeValidator.validateCodeQuality(formatted, 'preload');
    if (!validation.isValid) {
      console.warn('Generated preload script has validation issues:', validation.errors);
    }
  }
  
  return formatted;
}

/**
 * IPCハンドラーコードを生成
 */
export function generateHandlers(
  packages: PackageInfo[],
  errorHandler?: AutoCodeOption['errorHandler']
): string {
  const code = handlerGenerator.generate(packages, errorHandler);
  const formatted = codeFormatter.format(code);
  
  // デバッグ用バリデーション（開発時のみ）
  if (process.env['NODE_ENV'] === 'development') {
    const validation = codeValidator.validateCodeQuality(formatted, 'handler');
    if (!validation.isValid) {
      console.warn('Generated handler code has validation issues:', validation.errors);
    }
  }
  
  return formatted;
}

/**
 * TypeScript型定義を生成
 */
export function generateTypeDefinitions(
  packages: PackageInfo[],
  zodInfos: ZodObjectInfo[]
): string {
  const code = typeGenerator.generate(packages, zodInfos);
  const formatted = codeFormatter.format(code);
  
  // デバッグ用バリデーション（開発時のみ）
  if (process.env['NODE_ENV'] === 'development') {
    const validation = codeValidator.validateCodeQuality(formatted, 'types');
    if (!validation.isValid) {
      console.warn('Generated type definitions have validation issues:', validation.errors);
    }
  }
  
  return formatted;
}

/**
 * 生成コードの品質チェック（テスト用）
 */
export function validateGeneratedCode(
  code: string, 
  type: 'preload' | 'handler' | 'types'
): ValidationResult {
  return codeValidator.validateCodeQuality(code, type);
}
